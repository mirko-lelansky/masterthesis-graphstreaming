\chapter{Theorie}
In diesem Kapitel werden die theoretischen Grundlagen für die Arbeit beschrieben.

Dabei werden zuerst die verschiedenen Graphen erläutert. Anschließend wird der
Stream-Prozess beschrieben, mit den verschiedenen Modellen.

Danach folgt eine Vorstellung der verschiedenen Bibliotheken und welche
zugrundeliegende Streaming-Modelle dort zum Einsatz kommen. 

\section{Graphen}
Ein Graph G ist eine Datenstruktur mit der folgenden Definition: $G = (V,E)$.
Dabei ist V die Menge von Knoten und E die Menge von Kanten. Jede Kante besteht
dabei aus einen Paar von V. Bei einem ungerichteten Graphen ist das Paar, welches
die Kante representiert, ein ungeordnetes Paar oder andersgesagt eine
zweielementige Menge von V. Im Gegensatz dazu ist es bei einem gerichteten
Graphen ein geordnetes Paar.

\blockquote[\cite{Aigner2015}]{
[\dots]Ein Graph $G = (V,E)$ besteht aus einer endlichen Menge V von Ecken,
einer endlichen Menge E von Kanten, und einer Vorschrift, welche jeder Kante e
genau zwei (verschiedene oder gleiche) Ecken a und b zuordnet, die wir die
Endecken von e nennen. Normalerweise sind die Endecken a und b verschieden;
ist a = b, so nennen wir e eine Schlinge bei a. Hat e die Endecken a und b, so
sagen wir, e verbindet a und b.[\dots]}

Wenn die beide Elemente der Kante identisch sind spricht man auch von einer
Schlinge. Gibt es mehrere identische Kanten spricht man von Merhfachkanten.
Diese lassen sich zusammenfassen in dem nur eine Kante dargestellt mit einer
zusätzlichen Zahl, welche die Mehrfachkanten representiert.

Es werden zwei Klassen von Graphen unterschieden. Grpahen, welche nur keine
Schlingen und Mehrfachkanten zulassen, werden als einfache Graphen bezeichnet,
sonst als Multigraphen.

\blockquote[\cite{Gurski2010}]{
[\dots]Kanten, die mit mehr als zwei Knoten inzident sind, werden Hyperkanten
genannt. Graphen mit Hyperkanten heißen Hypergraphen. Wir betrachten in diesem
Buch jedoch vorwiegend einfache Graphen, also Graphen ohne multiple Kanten und
ohne Schleifen, und auch keine Hypergraphen.}

\section{Stream-Processing}
Stream-Processing beschreibt einen Prozess, bei dem die kontinuierlich
ankommenden Daten verarbeitet bzw. transformiert werden. Ein Stream ist eine
unendliche Liste von Elementen. Die Daten werden dabei von mindestens einer
Quelle gelesen. Anschliend werden diese von mindestens einer Verarbeitungseinheit
transformiert und abschließend in mindestens ein Ziel geschrieben. Quelle und
Ziel sind dabei externe Systeme, wie Datenbanken, Messaging-Platformen,~\dots,
welche in der Regel verschieden sind.

Die Idee des Stream-Processing ist schon sehr alt und im Laufe der Zeit sind
mehrere Modelle entstanden. Jedes Modell hat dabei gewisse Vorraussetzungen
und Einschränkungen, welche direkten Einfluss auf die konkreten Umsetzungen
haben. Es gibt die Modelle \enquote{Classical Streaming}, \enquote{semi-Streaming},
\enquote{W-Stream} und \enquote{StreamSort}.

\subsection{Classical Streaming}
Das erste Modell ist das \enquote{Classical Streaming}. Dieses wurde in den
1980 von Munro und Paterson definiert. Das Modell beschreibt die Verarbeitung
eines Streams durch eine RAM-Maschine. Der Stream ist dabei eine Folge von
Zeichen aus einem definierten Alphabet, welche sequenziell verarbeitet werden
können.

Die Prameter dieses Modells sind der Speicher der RAM-Maschine in Bits und
die Anzahl der Verarbeitungsdurchläufe des Streams. Beide Parameter sind dabei
Abhängig von der Länge des Streams und sollen möglichst klein im Verhältnis zur
Länge des Streams sein.

\foreignblockquote{english}[\cite{Ribichini2007}]{
In classical streaming, input data can be accessed sequentially in the form
of a data stream, and need to be processed using a working memory that
is small compared to the length of the stream. The main parameters of the
model are the number p of sequential passes over the data and the size s of the
working memory (in bits). [\dots]
}

Das Modell macht dabei keine Aussagen über die Laufzeit des Algorithmus. Diese
spielt für viele Probleme jedoch eine Rolle, deshalb wurde das
\enquote{semi-Streaming} Modell entwickelt.

\foreignblockquote{english}[\cite{Ribichini2007}]{
Notice that our definition imposes no restrictions on the amount
of computation performed by the RAM machine, as it is often the case when
dealing with external memory models, where it is assumed that I/O operations
take orders of magnitude longer than internal memory operations. There
are, however, applications in which the per-item processing time (average,
maximum) is a significant parameter that should be taken into account.
}

\subsection{semi-Streaming}
Das \enquote{semi-Streaming} Modell ist ein vereinfachtes Modell des
\enquote{Classical Streaming} Modells. Im Gegensatz zum \enquote{Classical Streaming}
wird hier festgelegt, das die Anzahl der Durchläufe beschränkt wird auf eins bzw.
einige wenige. Des Weiteren wird die Speichergröße der RAM-Maschine ebenfalls
auf beschränkt auf die logarithmische-Komplexitätsklasse.

\foreignblockquote{english}[\cite{Ribichini2007}]{
In particular, some recent papers show that several graph problems can be
solved with one or few passes in the Semi-streaming model [53] where the
working memory size is $O(n · \log n)$ for an input graph with n vertices
(or even $O(n^{1 + \epsilon})$, with $\epsilon < 1$, for applications like
spanners, for which linear memory in the number of vertices is provably not
sufficient): [\dots].
}

Diese Beschränkungen sorgen dafür, dass die Laufzeit des Algorithmus verbessert
wird. Jedoch haben diese Beschränkungen auch den Nachteil, dass sie nur
näherungsweise Ergebnisse liefern.

\foreignblockquote{english}[\cite{Ribichini2007}]{
Despite the heavy restrictions of the classical streaming model, major
success has been achieved for several data sketching and statistics problems,
e.g., approximate frequency moments [7], histogram maintenance [58],
L\textsuperscript{1} difference [55], where $O(1)$ passes and polylogarithmic
working space have proven enough to find approximate solutions (see also the
bibliographies in [14, 88]).
}

\subsection{W-Stream}
Das \enquote{W-Stream} Modell oder \enquote{Write-Stream} Modell ist eine
Erweiterung des \enquote{Classical Streaming}. Dabei wird jedes gelesene Element
des Streams nach der Verarbeitung in einen Ausgabe-Stream geschrieben. Die
Elemente können dabei bevor sie in den Ausgabe-Stream landen, verändert werden.
Wenn die Elemente nicht verändert werden, handelt es sich um einen speziellen
\enquote{W-Strem} nämlich den \enquote{Classical Stream}.

\foreignblockquote{english}[\cite{Ribichini2007}]{
In the W-Stream model [97], a streaming pass, while reading data from
the input stream and processing them in the working memory, produces items
that are sequentially appended to an output stream. [\dots]
Clearly, $\text{Stream}(p, s) \subseteq \text{W-Stream}(p, s)$ since at every
s/w-pass the output stream may simply consist of a copy of the input stream.
}

\subsection{StreamSort}
Das \enquote{StreamSort} Modell ist eine Erweiterung zum \enquote{W-Stream}.
Dabei schließt sich nach dem Schreibprozess noch ein Sortierungsprozess an. Dabei
werden die Elemente noch einer vorgegebenen globalen Sortierungsreihenfolge
sortiert.

\foreignblockquote{english}[\cite{Ribichini2007}]{
[\dots] This model extends classical streaming in two ways the ability to write
intermediate temporary streams and the ability to reorder them at each pass for
free. [\dots]
}

\section{Graph-Streaming Bibliotheken}
Graph-Streaming Bibliotheken sind Bibliotheken, welche die beiden Welten \gls{BigData}
und Graphen miteinander kombinieren wollen. Dabei geht es darum große Graphen
effizient und möglichst in Echtzeit mit Hilfe von Streams zu verarbeiten. Die
bedeutet, dass die Daten, welche von einem Stream verarbeitet werden, keine
einfachen Zeichenketten mehr sind, sondern zum Beispiel eine Kante des Graphens.
Je nach dem welches Streaming-Modell zum Einsatz kommt, können auch andere Daten
hinzu kommen. In dieser Arbeit werden die Bibliotheken \enquote{gelly-streaming},
\enquote{graphstream-project} und \enquote{Gephi} verglichen.

\subsection{gelly-streaming}
\enquote{gelly-streaming} ist eine Graph-Streaming Bibliothek für Apache Flink,
welche von Vasiliki Kalavri am KTH in Schweden im Jahr 2015 entwickelt wurde.
Apache Flink eine verteielte Platform für Batch- und Stream-Processing. Der Kern
von Apache Flink ist die Streaming-Engine, welche die eigentliche Verarbeitung
der Daten vornimmt. Alle \glspl{API} und Bibliotheken bauen auf der Engine auf.
Apache Flink wurde an der TU Berlin entwickelt und ist jetzt ein Apache Projekt.
Apache Flink ist in der Programmiersprache Java geschrieben. Es existiert jedoch
auch eine \gls{API} für Scala, welche nur ein Wrapper für Java darstellt. Dadurch
können Entwickler ihre Programme in Java oder Scala schreiben. Für alle anderen
Java-Alternativen müssen die benötigten Laufzeitbibliotheken mitgeliefert
werden. Die aktuelle Version von Flink ist 1.6.0 .

Bei der Bibliothek \enquote{gelly-streaming} kommt ein semi-streaming Verfahren
zum Einsatz, da die Bibliothek für Apache Flink entwickelt wurde. Dabei wird
jeweils immer eine Kante mit den beiden Knoten gespeichert. Jedoch keine
Zusatzinformationen, wie zum Beispiel ob die Kante hinzugefügt oder entfernt
wurde. Dies muss vom Anwender sichergestellt werden. \enquote{gelly-streaming}
ist ebenfalls in Java geschrieben und wird vorrangig von Studenten von
Vasiliki Kalavri weiterentwickelt. Allerdings ist anzumerken, dass die Bibliothek
zum Zeitpunkt der Arbeit noch im experimentellen Stadium ist und deshalb noch
keine Alpha/Beta/Finale-Versionen zur Verfügung stehen.

%% Bild mit gelly-streaming

\subsection{graphstream-project}
\enquote{graphstream-project} ist eine Java-Bibliothek für Graph-Streaming. Die
Bibiliothek wurde 2009 von der Gruppe RI\textsubscript{2}C-Gruppe am LITIS ein
Zusammenschluss von mehreren Universitäten und Firmen entwickelt. Derzeit wird
die Bibliothek von der Universität Le Havre weiterentwickelt. Die aktuelleste
Version ist 1.3 .


%% Streaming-Modell
%% Architektur

\subsection{Gephi}
\enquote{Gephi} ist eine Visualisierungsplatform für Graphen, welche in Java
geschrieben ist. Diese wurde 2009 an der Universität of Technologie of Compiègne
in Frankreich entwickelt. Derzeit wir die Platform vom Gehpi Consortium betreut.
Die aktuelleste Version ist 0.9.2 .

%% Streaming-Modell
%% Architektur
