\chapter{Realisierung}
In diesem Kapitel geht es darum, die wichtigsten Punkte der Realisierungen
zu beschreiben. Die Bibliothek \enquote{gelly-streaming} wird dabei wieder als
Referenz benutzt. Anschließend werden die Realisierung und deren Benutzbarkeit
analysiert und mögliche Lösungsen beschrieben.

\section{Analyse der Umsetzung}
Die Umsetzung der jeweiligen Versionen erfolgte nach den Methoden der
Softwareentwicklung. Dabei wurden die Entwürfe aus dem vorangegangen Kapitel
als Grundlage benutzt. Zusätzlich wurden die jeweiligen Dokumentationen und
Beispiele der Bibliotheken als Basis benutzt. Die verwendeten Testfälle wurden
dabei für die jeweilige Bibliothek angepasst. Des Weiteren lassen sich daraus
schnell und einfach weitere Testfälle erzeugen.

\subsection{Umsetzung der Referenz-Implementierung}
Die Referenz-Implementierung basiert auf dem Beispiel aus der Bibliothek. Der
wesentliche Unterschied zur Umsetzung aus der Bibliothek ist, dass die
Bibliothek Picocli\footnote{\url{https://picocli.info/}} für die Kommandozeile
benutzt wurde. Dies sorgt dafür, dass die Anwendung sich gut erweitern lässt.
Das Listing \ref{code:BipartiteGellyStreaming} zeigt den Code wie es in der
Bibliothek umgesetzt ist. Bei der Analyse des Beispieles fällt auf, dass die
Anwendung vier Informationen benötigt:

\begin{itemize}
\item dem Pfad für die Kanten
\item dem Pfad für die Ausgabe
\item dem Zeitinterwall für das Fenster
\item dem Trennzeichen für die Kanten
\end{itemize} 

\begin{listing}
\inputminted[breaklines=true]{java}{../material/code/BipartitenessCheckExample.java}
\caption{Umsetzung von Bipartitness von \enquote{gelly-streaming} \cite{Kalavri2018}}
\label{code:BipartiteGellyStreaming}
\end{listing}

Die ersten beiden Parameter sind dabei die wichtigsten. Die beiden anderen
Parameter sind im Beispiel schon definiert. Das Zeitintervall hat dabei eine
Länge von 500ms und das Trennzeichen ist das Tabzeichen. In der Methode
\enquote{parseParameters} werden die Paramter der Kommandozeile analysiert und
ggf. ein starten der Anwendung verhindert. Es sind dabei nur zwei Zustände
erlaubt. Der erste Zustand ist, wenn gar keine Parameter übergeben werden. Dann
werden die Kanten automatisch erzeugt und die Ergebnisse auf der Konsole
ausgegeben. Der zweite Zustand ist, wenn beide Parameter übergeben werden. Dann
werden die Kanten aus der Datei gelesen und auch in eine Datei geschrieben. Ein
Blick in die main-Methode zeigt jedoch, dass sich auch die Ausgabe über eine
Variable steuern lässt. Dies wird jedoch nicht genutzt. Der Grund dafür liegt
klar in der schlechten Transformation der Kommandozeilenparameter. Falls die
Anwendung dahingehend verändert wird, dass jemand nur einen einzigen Parameter
übergeben muss und jemand dies auch tut, kann die Anwendung nicht unterscheiden,
ob es sich dabei um den Pfad für die Kanten oder um dem Ausgabepfad handelt.

Das Problem des Beispiel ist, dass hier zwei verschiedene Konzepte falsch
verwendert werden. Nämlich die Konzepte von Optionen und Argumente wie, sie in
jeder Kommandozeile zum Einsatz kommen, wie zum Beispiel bei Linux dort sind die
meisten Programme Kommandozeilenanwendungen. Argumente sind Variablen, welche für
die Erfüllung der Aufgabe notwendig sind. Im Gegensatz dazu sind Optionen
Schalter, welche es dem Benutzer ermöglichen, gewisse Basiswerte zu verändern.
Ein klassisches Beispiel ist ein SSH- oder FTP-Client, diese ermöglichen es den
jeweiligen Port über eine Option zu ändern, dies ändert jedoch nicht die
Anwendungslogik. Wenn ein Benutzer jedoch keine Address mitgibt, dann wird der
Client eine Fehlermeldung ausgeben, denn die Address ist hier ein Argument. In
dem Beispiel müssten deshalb sowohl der Dateipfad für die Kanten als auch der
Dateipfad für die Ausgabe Optionen sein, denn es spielt für die Anwendung ja
keine Rolle ob die Pfade übergeben werden oder nicht. Denn wenn kein Dateipfad
für die Kanten übergeben werden, werden die Kanten generiert und wenn kein
Ausgabepfad übergeben wird, dann werden die Daten einfach in die Konsole
ausgegeben.

In der veränderten Realisierung wird dies auch so umgesetzt. Das Listing \ref{code:BipartiteReferenz}
zeigt den veränderten Code. Dabei wir der Fall entfernt, dass kein Dateipfad
für die Eingabedatei übergeben wurde. Der Dateipfad für die Kanten ist jetzt ein
verplichtendes Argument der Anwendung. Alle weiteren Daten wie Ausgabepfad,
Zeitintervall und Trennzeichen sind jetzt Optionen und können bei Bedarf angepasst
werden. Dadurch ist es schnell möglich die Eingabedatei zu ändern oder das
Zeitintervall anzupassen. Alle möglichen Argumente und Optionen werden dabei als
private Variablen angelegt und mit Annotationen versehen. Diese werden anschließend
von der Bibliothek verarbeitet.  Ein Problem bei der Implementierung bleibt aber
bestehen, in der \enquote{getEdgesDataSet} werden die Daten von der Umgebung
gelesen und gleichzeitig in Objekte transformiert. Für eine optimale Umsetzung
müsste das Einlesen der Daten getrennt von der Transformation erfolgen.
Dies spielt genau dann eine Rolle, wenn die Eingabequelle nicht mehr eine Datei,
sondern zum Beispiel ein Messaging-System ist. Da die Transformation der
Daten trotzdem erfolgen muss, egal welche Eingabequelle vorhanden ist und ein
Entwickler dann nicht mehr die \enquote{readTextFile}-Methode aufrufen kann.

\begin{listing}
\inputminted[breaklines=true]{java}{../material/code/GellyStreamingResult.java}
\caption{Umsetzung von Bipartitness}
\label{code:BipartiteReferenz}
\end{listing}

\subsection{Umsetzung von \enquote{graphstream-project}}
\subsection{Umsetzung von \enquote{Gephi}}
\section{Bewertung der Umsetzungen}
